#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <math.h>
#include <map>
#include "gzstream.h"
#include "simulate_illumina_reads.h"
#include "simulate.h"

using namespace std;

char *input;
char *input2;
int read_length=100;
float coverage=40;
int insertsize_mean=500;
int insertsize_sd=-1;
float error_rate=0.01;
int Is_cyclization = 0;
int Is_simulate_GC_bias = 0;
int Is_simulate_quality = 0;
int output_type = 1;
char *output;

ogzstream gz_outfile1;
ogzstream gz_outfile2;
ofstream outfile1;
ofstream outfile2;

double** correct_base_quality = NULL;
double** error_base_quality = NULL;
vector <double> circle_error_rate;

uint64_t error_total_num = 0;
map<int,uint64_t> InsertSize_distr;
uint64_t* error_pos_distr;
uint64_t total_read_pair = 0;

const char *MAKE_TIME="2011-04-22";
const char *VERSION="2.0";
const char *CONTACT1="yuanjianying@genomics.org.cn";
const char *CONTACT2="shiyujian@genomics.org.cn";

void Usage(){
	cout<<"Description:"<<endl;
	cout<<endl<<"\t   It is a program for simulating illumina PE reads,with a series of problems generate by illumina"<<endl;
	cout<<"\tsequencing machine in thought,such as insertsize distribution,error rate,heterozygosis SNP and "<<endl;
	cout<<"\theterozygosis Indel in diploid. "<<endl;
	cout<<"\t   User should set the value of insertsize_mean and insertsize_sd ,they are the mean value and standard"<<endl;
	cout<<"\tdeviation of the normal distribution that used as the model function when simulating insertsize "<<endl;
	cout<<"\tdistribution,usually we set the insertsize_sd to be 1/20 of the insertsize_mean.The normal distribution"<<endl;
	cout<<"\tfunction model we used in this program is f(x)=1/σ/sqrt(2*pi)*exp((x-μ)**2 / (2*σ**2)), and the insertsize "<<endl;
	cout<<"\tdistribution is simulated by Box-muller method."<<endl;
	cout<<"\t   To simulate illumina error rates on different cycles,we use the function f(x)=0.00001*x**4 as a "<<endl;
	cout<<"\tmodel function,because the error rate of a number of bases at the end is much larger than other area "<<endl;
	cout<<"\tin a read. "<<endl;
	cout<<"\t   If you want to simulate heterozygosis SNP and heterozygosis Indel reads, you should input two"<<endl;
	cout<<"\treference sequence, you can get the snp&indel sequence by the program \"simulate_snp_indel_seq\", but "<<endl;
	cout<<"\tremember that heterozygosis SNP rate and heterozygosis Indel rate is only exists in diploid. "<<endl;
	cout<<"\t   At last, you should set another several parameters, read length, coverage of reads ,input sequence ,"<<endl;
	cout<<"\toutput prefix and so on,the input1 sequence must be set ,because there is not default value."<<endl;
	cout<<endl<<"Program:simulate_illumina_reads"<<endl;
	cout<<"\tCompile Data: "<<MAKE_TIME<<endl;
	cout<<"\tHistory and contributions:\t"<<endl;
	cout<<"\t This program originally developed by Lu jianliang and Yue zhen(2010-03-01 version 1.0). "<<endl;
	cout<<"\t Later the version 2.0 program was proposed by Fan Wei. Shi Yujian and Hu xuesong contributes to "<<endl;
	cout<<"\t statistic analysis. According to the statistical analysis, the codes was revised by Yuan Jianying."<<endl;
	cout<<"\tVersion: "<<VERSION<<endl;
	cout<<"\tContact: "<<CONTACT1<<" "<<CONTACT2<<endl;
	cout<<endl<<"Usage:\tsimulate_illumina_reads [options]"<<endl;
	cout<<"\t-i 	<string>	input1,input reference genome sequence *.fa/*.fa.gz ."<<endl;
	cout<<"\t-I 	<string>	input2,for diploid genome, input another reference genome sequence which was "<<endl;
	cout<<"\t			generated by program \"simulate_snp_indel_seq\"."<<endl;
	cout<<"\t-l 	<int>		read_len,set read length,read1 and read2 have the same length,default:100."<<endl;
	cout<<"\t-x 	<float>		coverage,set	the sequencing coverage(sometimes called depth),default:40."<<endl;
	cout<<"\t-m 	<int>		insertsize_mean,set the average value of insert size,default:500."<<endl;
	cout<<"\t-v 	<int>		insertsize_sd,set the standard deviation of insert sizes, default:insertsize_mean/20."<<endl;
	cout<<"\t-e 	<float>		error_rate,set the average error rate over all cycles,default:0.01."<<endl;
	cout<<"\t-g 	<int>		whether simulate GC bias, 0:no, 1:yes, default:0."<<endl;
	cout<<"\t-q 	<int>		whether simulate quality value, 0:no, 1:yes, default:0."<<endl;
	cout<<"\t-f 	<int>		whether cyclize insert sequence(influence on PE-reads direction) 0: read1-forward read2-reverse, "<<endl;
	cout<<"\t			1: read1-reverse read2-forward, default:0."<<endl;
	cout<<"\t-c 	<int>		set output file type, 0:text, 1:*.gz, default:1."<<endl;
	cout<<"\t-o 	<string>	output,output file prefix default:illumina."<<endl;
	cout<<"\t-h	help,output help infomation."<<endl;
	cout<<endl<<"Example:"<<endl;
	cout<<endl<<"\t1. ./simulate_illumina_reads -i ref_sequence.fa"<<endl;
	cout<<"\t  Every parameter use the default one."<<endl;
	cout<<"\t2. ./simulate_illumina_reads -i ref_sequence.fa -l 100 -x 20 -o humen_500_100"<<endl;
	cout<<"\t  Just set read length and coverage you needed."<<endl;
	cout<<"\t3. ./simulate_illumina_reads -i ref_sequence.fa -o humen -m 600 -v 30 -e 0.01"<<endl;
	cout<<"\t  Set insertsize distribution and error rate."<<endl;
	cout<<"\t4. ./simulate_illumina_reads -i ref_sequence.fa -I snp_indel_ref_sequence.fa -o humen "<<endl;
	cout<<"\t  The genome is diploid and you want to produce heterozygosis SNPs  heterozygosis Indels in reads, "<<endl;
	cout<<"\t  the -I input was generated by program \"simulate_snp_indel_seq\"."<<endl;
	cout<<"\t5. ./simulate_illumina_reads -i ref_sequence.fa -g 1 -f 1 -c 0 -o humen "<<endl;
	cout<<"\t  Set simulate GCbias and the library is cyclization, output file is text format."<<endl;
	cout<<"\t6. ./simulate_illumina_reads -i ref_sequence.fa -q 1 -o humen "<<endl;
	cout<<"\t  Set simulate quality value, the ouput is in *.fq format."<<endl;
	exit(-1);
}

void Getopt(int argc,char *argv[]){
	int c;
	while ((c=getopt(argc,argv,"i:I:l:x:m:v:e:f:g:q:c:o:h"))!=-1)
	{
		switch(c){
			case 'i': input=optarg;break;
			case 'I': input2=optarg;break;
			case 'l': read_length=atoi(optarg);break;
			case 'x': coverage=atof(optarg);break;
			case 'm': insertsize_mean=atoi(optarg);break;
			case 'v': insertsize_sd=atoi(optarg);break;
			case 'e': error_rate=atof(optarg);break;
			case 'f': Is_cyclization=atoi(optarg);break;
			case 'g': Is_simulate_GC_bias=atoi(optarg);break;
			case 'q': Is_simulate_quality=atoi(optarg);break;
			case 'c': output_type=atoi(optarg);break;
			case 'o': output=optarg;break;
			case 'h': Usage();break;
			default: Usage();
		}
	}
}

int main(int argc, char *argv[])
{
	time_t time_start, time_end;
	time_start = time(NULL);
	
	if (argc==1)
	{
		Usage();
	}
	
	Getopt(argc,argv);
	//set insertsize sd default value
	if (insertsize_sd == -1){insertsize_sd = int(insertsize_mean/20);}
	//当前版本只能模拟100cycle内的质量值
	if (Is_simulate_quality && read_length > 100){cerr<<"Warning: program can be simulate 100 cycle quality value at most, the read length is greater than cycle number!"<<endl;exit(-1);}
		
	igzstream infile;
	igzstream infile2;

	ofstream log;
	ofstream insert_log;
	ofstream error_log;
	infile.open(input);
	ofstream snp,indel;

	if (!infile)
	{
		cerr<<"Error:unable to open input file:"<<input<<endl;
		exit(-1);
	}
	if(input2)
	{
		infile2.open(input2);
  	if (!infile2)
  	{
  		cerr<<"Error:unable to open input file:"<<input2<<endl;
  		exit(-1);
  	}
	}
	
	//initialize error position distribution table
	error_pos_distr = new uint64_t[read_length+1];
	for(int i=0; i<=read_length; i++)
	{
		error_pos_distr[i] = 0;
	}

	//initialize quality distribution table
	correct_base_quality = new double*[read_length];
	error_base_quality = new double*[read_length];
	for(int i=0; i<read_length; i++)
	{
		correct_base_quality[i] = new double[41];
		error_base_quality[i] = new double[41];
		for(int j=0; j<41; j++)
		{
			correct_base_quality[i][j] = 0.0;
			error_base_quality[i][j] = 0.0;
		}
	}
	
	if (!output)
	{
		char out1[100];
		char out2[100];
		char out3[100];
		char out4[100];
		char out5[100];
		if(Is_simulate_quality)
		{
			//get quality distribution table
			string exe_path = argv[0];
			get_quality_distr(exe_path);
			if(!output_type){
				sprintf(out1,"%s%d%s%d%s","illumina_",read_length,"_",insertsize_mean,"_1.fq");
				sprintf(out2,"%s%d%s%d%s","illumina_",read_length,"_",insertsize_mean,"_2.fq");
			}else{
				sprintf(out1,"%s%d%s%d%s","illumina_",read_length,"_",insertsize_mean,"_1.fq.gz");
				sprintf(out2,"%s%d%s%d%s","illumina_",read_length,"_",insertsize_mean,"_2.fq.gz");
			}
		}else{
			if(!output_type){
  			sprintf(out1,"%s%d%s%d%s","illumina_",read_length,"_",insertsize_mean,"_1.fa");
  			sprintf(out2,"%s%d%s%d%s","illumina_",read_length,"_",insertsize_mean,"_2.fa");
  		}else{
  			sprintf(out1,"%s%d%s%d%s","illumina_",read_length,"_",insertsize_mean,"_1.fa.gz");
  			sprintf(out2,"%s%d%s%d%s","illumina_",read_length,"_",insertsize_mean,"_2.fa.gz");
  		}
		}
		sprintf(out3,"%s%d%s%d%s","illumina_",read_length,"_",insertsize_mean,".log");
		sprintf(out4,"%s%d%s%d%s","illumina_",read_length,"_",insertsize_mean,".insertsize.distr");
		sprintf(out5,"%s%d%s%d%s","illumina_",read_length,"_",insertsize_mean,".error_rate.distr");
		if(!output_type){
			outfile1.open(out1);
			outfile2.open(out2);
		}else{
			gz_outfile1.open(out1);
			gz_outfile2.open(out2);
			}
		log.open(out3);
		insert_log.open(out4);
		error_log.open(out5);
	}else{
		
		char out1[500];char out2[500];char out3[500];char out4[500];char out5[500];
		
		if(Is_simulate_quality)	
		{
			//get quality distribution table
			string exe_path = argv[0];
//			cerr<<exe_path<<endl;
			get_quality_distr(exe_path);
			if(!output_type){
  			sprintf(out1,"%s%s%d%s%d%s",output,"_",read_length,"_",insertsize_mean,"_1.fq");
  			sprintf(out2,"%s%s%d%s%d%s",output,"_",read_length,"_",insertsize_mean,"_2.fq");
  		}else{
  			sprintf(out1,"%s%s%d%s%d%s",output,"_",read_length,"_",insertsize_mean,"_1.fq.gz");
  			sprintf(out2,"%s%s%d%s%d%s",output,"_",read_length,"_",insertsize_mean,"_2.fq.gz");
  		}
			
		}
		else
		{
			if(!output_type){
				sprintf(out1,"%s%s%d%s%d%s",output,"_",read_length,"_",insertsize_mean,"_1.fa");
				sprintf(out2,"%s%s%d%s%d%s",output,"_",read_length,"_",insertsize_mean,"_2.fa");
			}else{
				sprintf(out1,"%s%s%d%s%d%s",output,"_",read_length,"_",insertsize_mean,"_1.fa.gz");
				sprintf(out2,"%s%s%d%s%d%s",output,"_",read_length,"_",insertsize_mean,"_2.fa.gz");
			}
		}
		sprintf(out3,"%s%s%d%s%d%s",output,"_",read_length,"_",insertsize_mean,".log");
		sprintf(out4,"%s%s%d%s%d%s",output,"_",read_length,"_",insertsize_mean,".insertsize.distr");
		sprintf(out5,"%s%s%d%s%d%s",output,"_",read_length,"_",insertsize_mean,".error_rate.distr");
		if(!output_type){
			outfile1.open(out1);
			outfile2.open(out2);
		}else{
			gz_outfile1.open(out1);
			gz_outfile2.open(out2);
			}
		log.open(out3);
		insert_log.open(out4);
		error_log.open(out5);

	}

	if(!output_type)
	{
		if (!outfile1 || !outfile2)
		{
			cerr<<"Error:unable to open output file."<<endl;
			exit(1);
		}
	}else{
		if (!gz_outfile1 || !gz_outfile2)
		{
			cerr<<"Error:unable to open output file."<<endl;
			exit(1);
		}
	}
	if(!log){cerr<<"Error:unable to open output *log file."<<endl;exit(1);}
	if(!insert_log){cerr<<"Error:unalbe to open output insertsize distribution file."<<endl;exit(1);}
	if(!error_log){cerr<<"Error:unalbe to open output error rate distribution file."<<endl;exit(1);}
		
	//initialize cycle error rate
	if (error_rate>0)
	{
		if (error_rate<=0.001)
		{
			cerr<<"Error:error_rate is not bigger than basic error rate 0.001,you'd better set the value" 
			<<" either bigger or 0"<<endl;
			exit(-1);
		}else{
			log<<"Begin to simulate error distrubution"<<endl;
			circle_error_rate = error_distribution(error_rate,read_length);
			log<<"Finish to simulate error distrubution"<<endl;
		}
	}

	//start simulation
	Get_genome(infile,infile2,log);
	
//	cerr<<"error_total_num: "<<error_total_num<<endl;
	//ouput error position distribution
	error_log<<"**********Error rate distribution**********"<<endl;
	for(int i=1; i<=read_length; i++){
		error_log<<i<<"\t"<<double(error_pos_distr[i])/double(total_read_pair)<<endl;
	}
	
	//output insert size distribution
	insert_log<<"**********Insert size distribution************"<<endl
		<<"insert_size_len"<<"\t"<<"number"<<endl;
	map<int, uint64_t>::const_iterator map_it = InsertSize_distr.begin();
	while (map_it != InsertSize_distr.end())
	{
		insert_log<<map_it->first<<"\t"<<map_it->second<<endl;
		//cout<<map_it->second<<endl;
		map_it++;
	}
	
	for(int i=0; i<read_length; i++)
	{
		delete[] correct_base_quality[i];
		delete[] error_base_quality[i];
	}
	
	time_end = time(NULL);
	log<<"All done! Run time: "<<time_end-time_start<<"s."<<endl;
	
	return 0;
}

//read in quality distribution file and get the quality distribution table.
void get_quality_distr(string exe_path)
{
//	//get the path of quality distribution file
//	char buffer[1000];
//	getcwd(buffer, sizeof(buffer));
//	string current_path = buffer;

	string correct_base_quality_file, error_base_quality_file;
	int index = exe_path.find_last_of('/');
	if(index == -1){
		cerr<<"Error: program path wrong!"<<endl;
	}
	else{
		string directory_path = exe_path.substr(0,index);
		correct_base_quality_file = directory_path + "/quality_distribution_statistics/110226_I232_FC81EB6ABXX_L5_HUMfcmRABDMAAPE.soap.gz.match.snp.stat.rate";
		error_base_quality_file = directory_path + "/quality_distribution_statistics/110226_I232_FC81EB6ABXX_L5_HUMfcmRABDMAAPE.soap.gz.mis.snp.stat.revise.rate";
	}

	igzstream correct_qual_file (correct_base_quality_file.c_str());
	if ( ! correct_qual_file )
	{	cerr << "fail to open input file " << correct_base_quality_file <<", make sure quality statistics file place in program directory!"<< endl;
	}
	igzstream error_qual_file (error_base_quality_file.c_str());
	if ( ! error_qual_file )
	{	cerr << "fail to open input file " << error_base_quality_file <<", make sure quality statistics file place in program directory!"<< endl;
	}
	//get each cycle correct quality distribution
	for(int i=2; i<=40; i++)
	{
		string cyc_correct_quality_distr;
		getline(correct_qual_file,cyc_correct_quality_distr,'\n');
//				cerr<<cyc_correct_quality_distr<<endl;
		vector<string> correct_quality_distr_tokens;
		split(cyc_correct_quality_distr, correct_quality_distr_tokens, "\t");
		if(read_length > correct_quality_distr_tokens.size()){cerr<<"Warning: program can be simulate "<<correct_quality_distr_tokens.size()<<" cycle quality value at most, the read length is greater than cycle number!"<<endl;exit(-1);}
		for(int j = 0; j < read_length; j++)
		{
			string rate = correct_quality_distr_tokens[j];
			double current_rate = strtod(rate.c_str(),NULL);
			double accumulate_distr;
			accumulate_distr = current_rate + correct_base_quality[j][i-1];
			correct_base_quality[j][i] = accumulate_distr;
		}
	}
	//set correct_base_quality[j][40]=1
	for(int j = 0; j < read_length; j++)
	{
		correct_base_quality[j][40] = 1;
	}
	//get each cycle error quality distribution
	for(int i=2; i<=40; i++)
	{
		string cyc_error_quality_distr;
		getline(error_qual_file,cyc_error_quality_distr,'\n');
		
		vector<string> error_quality_distr_tokens;
		split(cyc_error_quality_distr, error_quality_distr_tokens, "\t");
		if(read_length > error_quality_distr_tokens.size()){cerr<<"Warning: program can be simulate "<<error_quality_distr_tokens.size()<<" cycle quality value at most, the read length is greater than cycle number!"<<endl;exit(-1);}
		for(int j = 0; j < read_length; j++)
		{
			string rate = error_quality_distr_tokens[j];
			double current_rate = strtod(rate.c_str(),NULL);
			double accumulate_distr;
			accumulate_distr = current_rate + error_base_quality[j][i-1];
			error_base_quality[j][i] = accumulate_distr;
		}
	}
	//set error_base_quality[j][40]=1
	for(int j = 0; j < read_length; j++)
	{
		error_base_quality[j][40] = 1;
	}
//			for(int i=0; i<read_length; i++)
//			{
//				for(int j=2; j<41; j++)
//				{
////					correct_base_quality[i][j] = 0.0;
//					cerr<<error_base_quality[i][j]<<" ";
//				}
//				cerr<<endl;
//			}
}

void Get_genome(igzstream &inf,igzstream &inf2,ofstream &log1){
	string line,line2,id,id_line,seq,seq2;
	long long readINgenome=0;
	while (getline(inf,line,'\n'))
	{
		if (line[0]=='>')
		{
			if (seq!="")
			{	
				//heterozygous SNP and heterozygous indel exists is diploid
				if(input2){
					getline(inf2,line2,'\n');
					if(id_line != line2){
						cerr<<"Error! file: "<< input2 <<" and "<<input<<" id don't match!"<<endl; exit(-1);
					}
					getline(inf2,seq2,'\n');
				}
				log1<<"Have finished reading scaffold "<<id<<endl;

				readINgenome+=get_reads(id_line,id,seq,seq2,log1,readINgenome);
				seq="";
			}
			id_line = line;
			line.erase(0,1);
//			id=line;
			int pos=line.find(" ");
			line=line.substr(0,pos);
			id=line;
		}else{
			seq+=line;
		}		
	}
	log1<<"Have finished reading scaffold "<<id<<endl;
	if(input2){
  	getline(inf2,line2,'\n');
  	if(id_line != line2){
  		cerr<<"Error! file: "<< input2 <<" and "<<input<<" id don't match!"<<endl; exit(-1);
  	}
  	getline(inf2,seq2,'\n');
	}

	readINgenome+=get_reads(id_line,id,seq,seq2,log1,readINgenome);
}


long long get_reads(string id_line,string id,string &sequ,string &sequ2,ofstream &log2,long long read_genome)
{
	string sequence;
	long long readonchr=0;
	if (sequ.size()<insertsize_mean)
	{
		return 0;
	}
	//convert lower case to upper case 
	for (int i=0;i<sequ.size();i++)
	{
		sequence.push_back(Bases[alphabet[sequ[i]]]);
	}
	int sequence_length=sequence.size();
	long long reads_pair_num=0;

	if (input2)
	{
		reads_pair_num=(long long)(sequence_length*coverage/read_length/2/2);
	}else{
		reads_pair_num=(long long)(sequence_length*coverage/read_length/2);
	}
	total_read_pair = total_read_pair + (long long)(sequence_length*coverage/read_length/2);

//	vector <double> circle_error_rate;
//	circle_error_rate = error_distribution(reads_pair_num);
//	if (error_rate>0)
//	{
//		if (error_rate<0.001)
//		{
//			cout<<"Error:error_rate is smaller than basic error rate 0.001,you'd better set the value" 
//			<<" either bigger or 0"<<endl;
//			exit(-1);
//		}else{
//			log2<<"Begin to simulate error distrubution"<<endl;
////			circle_error_rate=error_distribution();
//			circle_error_rate=error_distribution(reads_pair_num,error_rate,read_length);
//			log2<<"Finish to simulate error distrubution"<<endl;
//		}
//	}

	readonchr=output_reads(circle_error_rate,sequence,sequence_length,reads_pair_num,
		id,log2,read_genome);

	if (input2) //heterozygous SNP and heterozygous indel exists is diploid
	{
		sequence_length=sequ2.size();
		reads_pair_num=(long long)(sequence_length*coverage/read_length/2/2);

//		vector <double> circle_error_rate;
//		if (error_rate>0)
//		{
//			log2<<"Begin to simulate error distrubution"<<endl;
//			circle_error_rate=error_distribution(reads_pair_num, error_rate, read_length);
//			log2<<"Finish to simulate error distrubution"<<endl;
//		}
		long long readonchr2=read_genome+readonchr;

		readonchr+=output_reads(circle_error_rate,sequ2,sequence_length,reads_pair_num,
			id,log2,readonchr2);
	}
	return readonchr;
}


long long output_reads(vector <double> err_dist,string &seq,int seqlen, int rd_pair, string id_seq, ofstream &log3,long long reads_all)
{
	int reads_count=0;
	log3<<"Begin to output reads"<<endl;
	srand((unsigned)time(NULL));
	for(uint64_t i=0; i < rd_pair; i++)
	{
		//simulate insertsize
		int insertsize = simulate_insertsize(insertsize_mean,insertsize_sd);
		if (insertsize<read_length){i--;continue;}
		if (seqlen<insertsize){return reads_count;}
		int pos=int(rand()%seqlen);
		if (pos+insertsize>seqlen){i--;continue;}
			
		//get insert seq
		string substr=seq.substr(pos,insertsize);
		
		
		//simulate GC bias
		if(Is_simulate_GC_bias){
			if(simulate_GC_bias(substr)){i--;continue;}
		}
		
		//insertsize statistics
		if(InsertSize_distr[insertsize]>0)
		{
			InsertSize_distr[insertsize]++;
		}else{
			InsertSize_distr[insertsize] = 1;
		}
		
		reads_count++;
		
		//get read1 and read2
		string read1=substr.substr(0,read_length);
		string read2=substr.substr(insertsize-read_length,read_length);
		
		if ( Is_cyclization == 1 )
		{
			read1=reversecomplementary(read1);
		}else if (insertsize_mean>0)
		{
			read2=reversecomplementary(read2);
		}else{
			cout<<"Error:insertsize mean is smaller than 0"<<endl;
			exit(-1);
		}
		
		//simulate error base
		int errorpos1[100];
		int errorpos2[100];
		char errorbase1[100];
		char errorbase2[100];
		int error_count1=0;
		int error_count2=0;
		vector<int> error_pos1;
		vector<int> error_pos2;
	
		if (error_rate>=0.001)
		{	
			for (int j=0;j<read_length;j++)
			{
//				double num=double(rand()%rd_pair);
				double num=double(rand())/double(RAND_MAX);
				if(num<err_dist[j])
				{
					errorpos1[error_count1]=j;
					error_pos1.push_back(j);
					error_pos_distr[j+1]++;
					errorbase1[error_count1]=read1[j];
					read1[j]=get_error_match(read1[j]);
					error_count1++;
				}
			}
			for (int j=0;j<read_length;j++)
			{
				double num=double(rand())/double(RAND_MAX);
//				double num=double(rand()%rd_pair);
				if (num<err_dist[j])
				{
					errorpos2[error_count2]=j;
					error_pos2.push_back(j);
					errorbase2[error_count2]=read2[j];
					read2[j]=get_error_match(read2[j]);
					error_count2++;
				}
			}
		}
		
		//simulate quality line
		string quality_str1, quality_str2;
		if(Is_simulate_quality)
		{
			quality_str1 = simulate_quality(error_pos1, read_length,correct_base_quality,error_base_quality);
			quality_str2 = simulate_quality(error_pos2, read_length,correct_base_quality,error_base_quality);
		}
		
		//output simulate reads
		int num1=int(rand()%2);
		if (reads_count%10000==0)
		{
			log3<<"Output "<<reads_count<<" reads"<<endl;
		}
		if (num1==0)
		{
//				o1<<">"<<id_seq<<"_"<<insertsize_mean<<"_"<<read_length<<"_"<<pos<<"_"<<reads_count<<"_"<<1<<endl<<read1<<endl;
			if(Is_simulate_quality)
			{
//				o1<<"@read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"_"<<1<<" "<<id_seq<<" "<<pos+1<<" "<<read_length<<" "<<insertsize<<" ";
				if(!output_type){
					outfile1<<"@read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"_"<<1<<" "<<id_seq<<" "<<pos+1<<" "<<read_length<<" "<<insertsize<<" ";
  			}else{
  				gz_outfile1<<"@read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"_"<<1<<" "<<id_seq<<" "<<pos+1<<" "<<read_length<<" "<<insertsize<<" ";
  			}
  			if (error_count1>0)
  			{
  				for (int a=0;a<error_count1;a++)
  				{
//  					o1<<errorpos1[a]+1<<","<<errorbase1[a]<<";";
						if(!output_type){
							outfile1<<errorpos1[a]+1<<","<<errorbase1[a]<<";";
						}else{
							gz_outfile1<<errorpos1[a]+1<<","<<errorbase1[a]<<";";
						}
  				}
  			}
  			
//  			o1<<endl<<read1<<endl
//					<<"+"<<endl
//					<<quality_str1<<endl;
				if(!output_type){
    			outfile1<<endl<<read1<<endl
  					<<"+"<<endl
  					<<quality_str1<<endl;
				}else{
    			gz_outfile1<<endl<<read1<<endl
  					<<"+"<<endl
  					<<quality_str1<<endl;
				}
					
			}else{
//  			o1<<">read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"_"<<1<<" "<<id_seq<<" "<<pos+1<<" "<<read_length<<" "<<insertsize<<" ";
  			if(!output_type){
  				outfile1<<">read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"_"<<1<<" "<<id_seq<<" "<<pos+1<<" "<<read_length<<" "<<insertsize<<" ";
  			}else{
  				gz_outfile1<<">read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"_"<<1<<" "<<id_seq<<" "<<pos+1<<" "<<read_length<<" "<<insertsize<<" ";
  			}
  				
  			if (error_count1>0)
  			{
  				for (int a=0;a<error_count1;a++)
  				{
  					
//  					o1<<errorpos1[a]+1<<","<<errorbase1[a]<<";";
						if(!output_type){
							outfile1<<errorpos1[a]+1<<","<<errorbase1[a]<<";";
						}else{
							gz_outfile1<<errorpos1[a]+1<<","<<errorbase1[a]<<";";
						}
							
  				}
  			}
  			if(!output_type){outfile1<<endl<<read1<<endl;}
  				else{gz_outfile1<<endl<<read1<<endl;}
//  			o1<<endl<<read1<<endl;
			}
			error_total_num+= error_count1;
			
//				o2<<">"<<id_seq<<"_"<<insertsize_mean<<"_"<<read_length<<"_"<<pos<<"_"<<reads_count<<"_"<<2<<endl<<read2<<endl;

			if(Is_simulate_quality)
			{
//  			o2<<"@read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"_"<<2<<" "<<id_seq<<" "<<pos+i-read_length+1<<" "<<read_length<<" "<<insertsize<<" ";
  			if(!output_type){
  				outfile2<<"@read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"_"<<2<<" "<<id_seq<<" "<<pos+insertsize-read_length+1<<" "<<read_length<<" "<<insertsize<<" ";
  			}else{
  				gz_outfile2<<"@read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"_"<<2<<" "<<id_seq<<" "<<pos+insertsize-read_length+1<<" "<<read_length<<" "<<insertsize<<" ";
  			}
  			if (error_count2>0)
  			{
  				for (int a=0;a<error_count2;a++)
  				{
//  					o2<<errorpos2[a]+1<<","<<errorbase2[a]<<";";
						if(!output_type){
							outfile2<<errorpos2[a]+1<<","<<errorbase2[a]<<";";
						}else{
							gz_outfile2<<errorpos2[a]+1<<","<<errorbase2[a]<<";";
						}
  				}
  			}
//  			o2<<endl<<read2<<endl
//					<<"+"<<endl
//					<<quality_str2<<endl;
				if(!output_type){
    			outfile2<<endl<<read2<<endl
  					<<"+"<<endl
  					<<quality_str2<<endl;
				}else{
    			gz_outfile2<<endl<<read2<<endl
  					<<"+"<<endl
  					<<quality_str2<<endl;
				}
			}else{
				
//  			o2<<">read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"_"<<2<<" "<<id_seq<<" "<<pos+i-read_length+1<<" "<<read_length<<" "<<insertsize<<" ";
  			if(!output_type){
  				outfile2<<">read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"_"<<2<<" "<<id_seq<<" "<<pos+insertsize-read_length+1<<" "<<read_length<<" "<<insertsize<<" ";
  			}else{
  				gz_outfile2<<">read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"_"<<2<<" "<<id_seq<<" "<<pos+insertsize-read_length+1<<" "<<read_length<<" "<<insertsize<<" ";
  			}
  			if (error_count2>0)
  			{
  				for (int a=0;a<error_count2;a++)
  				{
  					if(!output_type){
  						outfile2<<errorpos2[a]+1<<","<<errorbase2[a]<<";";
  					}else{
  						gz_outfile2<<errorpos2[a]+1<<","<<errorbase2[a]<<";";
  					}
//  					o2<<errorpos2[a]+1<<","<<errorbase2[a]<<";";
  				}
  			}
//  			o2<<endl<<read2<<endl;
				if(!output_type){
					outfile2<<endl<<read2<<endl;
				}else{
					gz_outfile2<<endl<<read2<<endl;
				}
			}
			
			error_total_num+= error_count2;
			
		}else{
//				o1<<">"<<id_seq<<"_"<<insertsize_mean<<"_"<<read_length<<"_"<<pos<<"_"<<reads_count<<"_"<<1<<endl<<read2<<endl;
			if(Is_simulate_quality)
			{
				if(!output_type){
					outfile1<<"@read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"_"<<1<<" "<<id_seq<<" "<<pos+insertsize-read_length+1<<" "<<read_length<<" "<<insertsize<<" ";
				}else{
					gz_outfile1<<"@read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"_"<<1<<" "<<id_seq<<" "<<pos+insertsize-read_length+1<<" "<<read_length<<" "<<insertsize<<" ";
				}
//  			o1<<"@read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"_"<<1<<" "<<id_seq<<" "<<pos+i-read_length+1<<" "<<read_length<<" "<<insertsize<<" ";
  			if (error_count2>0)
  			{
  				for (int a=0;a<error_count2;a++)
  				{
//  					o1<<errorpos2[a]+1<<","<<errorbase2[a]<<";";
						if(!output_type){
							outfile1<<errorpos2[a]+1<<","<<errorbase2[a]<<";";
						}else{
							gz_outfile1<<errorpos2[a]+1<<","<<errorbase2[a]<<";";
						}
  				}
  			}
  			
//  			o1<<endl<<read2<<endl
//					<<"+"<<endl
//					<<quality_str2<<endl;
				if(!output_type){
    			outfile1<<endl<<read2<<endl
  					<<"+"<<endl
  					<<quality_str2<<endl;
				}else{
    			gz_outfile1<<endl<<read2<<endl
  					<<"+"<<endl
  					<<quality_str2<<endl;
				}
			}else{
				if(!output_type){
					outfile1<<">read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"_"<<1<<" "<<id_seq<<" "<<pos+insertsize-read_length+1<<" "<<read_length<<" "<<insertsize<<" ";
				}else{
					gz_outfile1<<">read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"_"<<1<<" "<<id_seq<<" "<<pos+insertsize-read_length+1<<" "<<read_length<<" "<<insertsize<<" ";
				}
//  			o1<<">read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"_"<<1<<" "<<id_seq<<" "<<pos+i-read_length+1<<" "<<read_length<<" "<<insertsize<<" ";
  			if (error_count2>0)
  			{
  				for (int a=0;a<error_count2;a++)
  				{
//  					o1<<errorpos2[a]+1<<","<<errorbase2[a]<<";";
  					if(!output_type){
  						outfile1<<errorpos2[a]+1<<","<<errorbase2[a]<<";";
  					}else{
  						gz_outfile1<<errorpos2[a]+1<<","<<errorbase2[a]<<";";
  					}
  				}
  			}
  			if(!output_type){
  				outfile1<<endl<<read2<<endl;
  			}else{
  				gz_outfile1<<endl<<read2<<endl;
  			}
//  			o1<<endl<<read2<<endl;
			}
			error_total_num+= error_count2;
			
//				o2<<">"<<id_seq<<"_"<<insertsize_mean<<"_"<<read_length<<"_"<<pos<<"_"<<reads_count<<"_"<<2<<endl<<read1<<endl;

			if(Is_simulate_quality)
			{
				if(!output_type){
					outfile2<<"@read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"_"<<2<<" "<<id_seq<<" "<<pos+1<<" "<<read_length<<" "<<insertsize<<" ";
				}else{
					gz_outfile2<<"@read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"_"<<2<<" "<<id_seq<<" "<<pos+1<<" "<<read_length<<" "<<insertsize<<" ";
				}
//  			o2<<"@read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"_"<<2<<" "<<id_seq<<" "<<pos+1<<" "<<read_length<<" "<<insertsize<<" ";
  			if (error_count1>0)
  			{
  				for (int a=0;a<error_count1;a++)
  				{
  					if(!output_type){
  						outfile2<<errorpos1[a]+1<<","<<errorbase1[a]<<";";
  					}else{
  						gz_outfile2<<errorpos1[a]+1<<","<<errorbase1[a]<<";";
  					}
//  					o2<<errorpos1[a]+1<<","<<errorbase1[a]<<";";
  				}
  			}
  			if(!output_type){
    			outfile2<<endl<<read1<<endl
  					<<"+"<<endl
  					<<quality_str1<<endl;
  			}else{
    			gz_outfile2<<endl<<read1<<endl
  					<<"+"<<endl
  					<<quality_str1<<endl;
  			}
//  			o2<<endl<<read1<<endl
//					<<"+"<<endl
//					<<quality_str1<<endl;
			}else{
//  			o2<<">read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"_"<<2<<" "<<id_seq<<" "<<pos+1<<" "<<read_length<<" "<<insertsize<<" ";
  			if(!output_type){
  				outfile2<<">read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"_"<<2<<" "<<id_seq<<" "<<pos+1<<" "<<read_length<<" "<<insertsize<<" ";
  			}else{
  				gz_outfile2<<">read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"_"<<2<<" "<<id_seq<<" "<<pos+1<<" "<<read_length<<" "<<insertsize<<" ";
  			}
  			if (error_count1>0)
  			{
  				for (int a=0;a<error_count1;a++)
  				{
  					if(!output_type){
  						outfile2<<errorpos1[a]+1<<","<<errorbase1[a]<<";";
  					}else{
  						gz_outfile2<<errorpos1[a]+1<<","<<errorbase1[a]<<";";
  					}
//  					o2<<errorpos1[a]+1<<","<<errorbase1[a]<<";";
  				}
  			}
  			if(!output_type){
  				outfile2<<endl<<read1<<endl;
  			}else{
  				gz_outfile2<<endl<<read1<<endl;
  			}
//  			o2<<endl<<read1<<endl;
			}
			
			error_total_num+= error_count1;
				
		}
		
	}

	log3<<"Finish output reads"<<endl;
	return reads_count;
}
